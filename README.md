# OSlab

实验解析：https://www.zhihu.com/column/c_142990858

## 实验一 linux 内核编译及添加系统调用

1. 设计目的

Linux 是开源操作系统，用户可以根据自身系统需要裁剪、修改内核，定制出功能更加 合适、运行效率更高的系统，因此，编译 linux 内核是进行内核开发的必要基本功。

在系统中根据需要添加新的系统调用是修改内核的一种常用手段，通过本次实验，读 者应理解 linux 系统处理系统调用的流程以及增加系统调用的方法。

2. 内容要求

(1) 添加一个系统调用，实现对指定进程的 nice 值的修改或读取功能，并返回进程最 新的 nice 值及优先级 prio。建议调用原型为:

int mysetnice(pid_t pid, int flag, int nicevalue, void __user * prio, void __user * nice);

参数含义: pid:进程 ID。

flag:若值为 0，表示读取 nice 值;若值为 1，表示修改 nice 值。

Prio、nice:进程当前优先级及 nice 值。 返回值:系统调用成功时返回 0，失败时返回错误码 EFAULT。 

(2) 写一个简单的应用程序测试(1)中添加的系统调用。

(3) 若程序中调用了 linux 的内核函数，要求深入阅读相关函数源码。

## 实验二 linux 内核模块编程

1. 设计目的

Linux 提供的模块机制能动态扩充 linux 功能而无需重新编译内核，已经广泛应用在 linux 内核的许多功能的实现中。在本实验中将学习模块的基本概念、原理及实现技术，然后利 用内核模块编程访问进程的基本信息，从而加深对进程概念的理解、对模块编程技术的掌 握。

2. 内容要求

(1) 设计一个模块，要求列出系统中所有内核线程的程序名、PID 号、进程状态及 进程优先级。

(2) 设计一个带参数的模块，其参数为某个进程的 PID 号，该模块的功能是列出该 进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID 号。

(3) 请根据自身情况，进一步阅读分析程序中用到的相关内核函数的源码实现。

## 实验四 linux 进程管理

1. 设计目的

(1) 熟悉 linux 的命令接口。

(2) 通过对 linux 进程控制的相关系统调用的编程应用，进一步加深对进程概念的理解， 明确进程和程序的联系和区别，理解进程并发执行的具体含义。

(3) 通过 Linux 管道通信机制、消息队列通信机制、共享内存通信机制的使用，加深 对不同类型的进程通信方式的理解。

(4) 通过对 linux 的 Posix 信号量的应用，加深对信号量同步机制的理解。 (5)请根据自身情况，进一步阅读分析相关系统调用的内核源码实现。

2. 设计内容

(1)熟悉 linux 常用命令:pwd，useradd，passwd, who, ps, pstree, kill, top, ls, cd, mkdir, rmdir, cp, rm, mv, cat, more, grep 等。

(2) 实现一个模拟的 shell:

编写三个不同的程序 cmd1.c，cmd2.c，cmd3.c，每个程序的功能自定，分别编译成可执 行文件 cmd1，cmd2，cmd3。然后再编写一个程序，模拟 shell 程序的功能，能根据用户输 入的字符串(表示相应的命令名)，去为相应的命令创建子进程并让它去执行相应的程序，而父进程则等待子进程结束，然后再等待接收下一条命令。如果接收到的命令为 exit，则父 进程结束;如果接收到的命令是无效命令，则显示“Command not found”，继续等待。

(3) 实现一个管道通信程序:

由父进程创建一个管道，然后再创建 3 个子进程，并由这三个子进程利用管道与父进程 之间进行通信:子进程发送信息，父进程等三个子进程全部发完消息后再接收信息。通信的 具体内容可根据自己的需要随意设计，要求能试验阻塞型读写过程中的各种情况，测试管道 的默认大小，并且要求利用 Posix 信号量机制实现进程间对管道的互斥访问。运行程序，观 察各种情况下，进程实际读写的字节数以及进程阻塞唤醒的情况。

(4) 利用 linux 的消息队列通信机制实现两个线程间的通信:

编写程序创建两个线程:sender 线程和 receive 线程，其中 sender 线程运行函数 sender()， 它创建一个消息队列，然后，循环等待用户通过终端输入一串字符，将这串字符通过消息队 列发送给 receiver 线程，直到用户输入“exit”为止;最后，它向 receiver 线程发送消息“end”， 并且等待 receiver 的应答，等到应答消息后，将接收到的应答信息显示在终端屏幕上，删除 相关消息队列，结束程序的运行。Receiver 线程运行 receive()，它通过消息队列接收来自 sender 的消息，将消息显示在终端屏幕上，直至收到内容为“end”的消息为止，此时，它 向 sender 发送一个应答消息“over”，结束程序的运行。使用无名信号量实现两个线程之间 的同步与互斥。

(5) 利用 linux 的共享内存通信机制实现两个进程间的通信:

编写程序 sender，它创建一个共享内存，然后等待用户通过终端输入一串字符，并将这 串字符通过共享内存发送给 receiver;最后，它等待 receiver 的应答，收到应答消息后，将 接收到的应答信息显示在终端屏幕上，删除共享内存，结束程序的运行。编写 receiver 程序， 它通过共享内存接收来自 sender 的消息，将消息显示在终端屏幕上，然后再通过该共享内 存向 sender 发送一个应答消息“over”，结束程序的运行。使用有名信号量或 System V 信号 量实现两个进程对共享内存的互斥及同步使用。

## 实验五 简单文件系统的实现

1. 设计目的

通过具体的文件存储空间的管理、文件的物理结构、目录结构和文件操作的实现，加深对文件系统内部数据结构、功能以及实现过程的理解。

2. 内容要求

(1) 在内存中开辟一个虚拟磁盘空间作为文件存储分区，在其上实现一个简单的基于多 级目录的单用户单任务系统中的文件系统。在退出该文件系统的使用时，应将该虚拟文件系 统以一个文件的方式保存到磁盘上，以便下次可以再将它恢复到内存的虚拟磁盘空间中。

(2) 文件存储空间的分配可采用显式链接分配或其他的办法。

(3) 空闲磁盘空间的管理可选择位示图或其他的办法。如果采用位示图来管理文件存储 空间，并采用显式链接分配方式，那么可以将位示图合并到 FAT 中。

(4) 文件目录结构采用多级目录结构。为了简单起见，可以不使用索引结点，其中的每 个目录项应包含文件名、物理地址、长度等信息，还可以通过目录项实现对文件的读和写的 保护。

(5) 要求提供以下操作命令:
- my_format:对文件存储器进行格式化，即按照文件系统的结构对虚拟磁盘空间进行布局，并在其上创建根目录以及用于管理文件存储空间等的数据结构。
- my_mkdir:用于创建子目录。
- my_rmdir:用于删除子目录。
- my_ls:用于显示目录中的内容。
- my_cd:用于更改当前目录。 
- my_create:用于创建文件。
- my_open:用于打开文件。
- my_close:用于关闭文件。
- my_write:用于写文件。
- my_read:用于读文件。
- my_rm:用于删除文件。
- my_exitsys:用于退出文件系统。
